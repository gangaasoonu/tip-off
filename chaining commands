& to run in background
; .... run commands in sequence
&& ... to run second command, only if first 1'st command succeeds
|| ... to run second command, only if first 1'st command fails or exist code of 1'st command is 1
! ... except command rm -r !(*.html) will delete all files except .html
ping -c3 www.tecmint.com && echo "Verified" || echo "Host Down"  .. chaining && with || 
| pipe operator ..ls -l | less  send output of first command as input to second command ...
{} ... combine multiple commands & exceute them conditionally [ -d bin ] || { echo Directory does not exist, creating directory now.; mkdir bin; } && echo Directory exists.
()  ... Precedence Operator (Command_x1 &&Command_x2) || (Command_x3 && Command_x4)   3 & 4 will run if even if 1 or 2 or both 1 & 2 fails
\ .. concatenate commands in multiple lines

# Thx to https://www.tecmint.com/chaining-operators-in-linux-with-practical-examples/

Learn to use Traces  strace, gdb, ptrace to identify, why irfaniew can't open images, when I double click on it.. Oct 21 2025
https://thelinuxcode.com/ptrace-system-call-c/

Using ptrace system calls, the tracer can:

    Stop and resume execution of the tracee
    Read and write tracee process memory, registers
    Intercept and modify system calls made by the tracee
    Change execution path by modifying key registers
    Monitor signals, system call arguments, instruction changes

In essence, ptrace offers complete control over another Linux process. The tracee allows itself to be traced, while the tracer does the actual peeking and poking.

This fundamental ability is what enables powerful applications like debuggers, tracers, sandboxing tools and more.

Over 15% of Linux workloads use ptrace-based tools for debugging, monitoring and security policies. That‘s how ubiquitous it is!
A Brief History Behind ptrace

Ptrace was first introduced in Linux 1.0 released in 1994, along with support for system calls and signals…

Discuss original goals of ptrace tied to gdb, process control use cases
Real-world Usage of ptrace Power

Let‘s now look at some examples of popular Linux tools that are built on capabilities offered by the humble ptrace system call:
Debuggers

The granddaddy of ptrace usage – debuggers like the ubiquitous gdb rely on ptrace to control execution of a debuggee process. Setting breakpoints, inspecting call stacks, and stepping through code line-by-line requires stopping and resuming processes, examining memory and registers. Ptrace delivers all these fundamentals for building debuggers.

Similar debuggers like lldb, mdb also use ptrace for interfacing with Linux processes.
Tracers

strace is another common tool enabled by ptrace to show a trace of all system calls made by a process and their arguments. To efficiently intercept calls and peek into their arguments, strace will attach to a process using ptrace before it runs code.

System call tracing forms a major portion of ptrace usage in real-systems.
Sandboxing

Modern Linux container platforms like Docker depend on namespaces and cgroups to provide isolation for processes. seccomp policies that restrict permissible syscalls require ptrace to intercept calls without having to modify programs.

The Chrome/Chromium sandbox also uses ptrace in conjunction with seccomp to limit browser attacks by containing process behaviors.
Instruction Tracing

Ptrace allows tracers to be notified after every instruction step and inspect changes to registers and memory at a fundamental level.

Tools like Qemu and Valgrind leverage this to track instruction-level execution for emulation and memory check purposes respectively.

As we see above, ptrace enabled fundamental low-level interfacing with processes, which sparked an entire ecosystem of Linux tools for debugging, tracing and monitoring different workloads.
Comparison With Other Linux Tracing APIs

Ptrace forms just one part of the rich tracing capabilities offered in the Linux kernel. Some alternatives like kprobes and kernel tracing are also useful in different situations:

Compare with kprobes, tracepoints, eBPF etc
Mastering Tracee Control With Ptrace

Now that we have seen a wide variety of utilities made possible due to ptrace, let us go deeper into the critical trace control functionality it offers…

Dive into stopping, resuming tracee, altering execution path, intercepting syscalls etc.
Safely Using Ptrace in Custom Tools

While ptrace is invaluable for building instrumentation tools, its unchecked powers can also make it dangerous from a security perspective. Things to keep in mind:

Discuss attack scenarios, risks and best practices for security
The Road Ahead for Ptrace

Ptrace has come really far from its origins around Linux 1.0 to enabling performance analyzers, container isolation and much more. But it also has scope for improvement when it comes to light-weight tracing and richer interfaces.

Talk about eBPF, improvements in kernel, better interfaces like PTRACE_SEIZE


Thx https://thelinuxcode.com/ptrace-system-call-c/


**** SAFETY  https://www.tecmint.com/sudoers-configurations-for-setting-sudo-in-linux/

sudo allows a permitted user to execute a command as root (or another user), as specified by the security policy:

    It reads and parses /etc/sudoers, looks up the invoking user and its permissions,
    then prompts the invoking user for a password (normally the user’s password, but it can as well be the target user’s password. Or it can be skipped with NOPASSWD tag),
    after that, sudo creates a child process in which it calls setuid() to switch to the target user
    next, it executes a shell or the command given as arguments in the child process above.

Below are ten /etc/sudoers file configurations to modify the behavior of sudo command using Defaults entries.

$ sudo cat /etc/sudoers

/etc/sudoers File

#
# This file MUST be edited with the 'visudo' command as root.
#
# Please consider adding local content in /etc/sudoers.d/ instead of
# directly modifying this file.
#
# See the man page for details on how to write a sudoers file.
#
Defaults	env_reset
Defaults	mail_badpass
Defaults	secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
Defaults	logfile="/var/log/sudo.log"
Defaults	lecture="always"
Defaults	badpass_message="Password is wrong, please try again"
Defaults	passwd_tries=5
Defaults	insults
Defaults	log_input,log_output

Types of Defaults Entries

Defaults                parameter,   parameter_list     #affect all users on any host
Defaults@Host_List      parameter,   parameter_list     #affects all users on a specific host
Defaults:User_List      parameter,   parameter_list     #affects a specific user
Defaults!Cmnd_List      parameter,   parameter_list     #affects  a specific command 
Defaults>Runas_List     parameter,   parameter_list     #affects commands being run as a specific user

For the scope of this guide, we will zero down to the first type of Defaults in the forms below. Parameters may be flags, integer values, strings, or lists.

You should note that flags are implicitly boolean and can be turned off using the '!' operator, and lists have two additional assignment operators, += (add to list) and -= (remove from list).

Defaults     parameter
OR
Defaults     parameter=value
OR
Defaults     parameter -=value   
Defaults     parameter +=value  
OR
Defaults     !parameter       

1. Set a Secure PATH

This is the path used for every command run with sudo, it has two importances:

    Used when a system administrator does not trust sudo users to have a secure PATH environment variable
    To separate “root path” and “user path”, only users defined by exempt_group are not affected by this setting.

To set it, add the line:

Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"

2. Enable sudo on TTY User Login Session

To enable sudo to be invoked from a real tty but not through methods such as cron or cgi-bin scripts, add the line:

Defaults  requiretty   

3. Run Sudo Command Using a pty

A few times, attackers can run a malicious program (such as a virus or malware) using sudo, which would again fork a background process that remains on the user’s terminal device even when the main program has finished executing.

To avoid such a scenario, you can configure sudo to run other commands only from a psuedo-pty using the use_pty parameter, whether I/O logging is turned on or not as follows:

Defaults  use_pty

4. Create a Sudo Log File

By default, sudo logs through syslog(3). However, to specify a custom log file, use the logfile parameter like so:

Defaults  logfile="/var/log/sudo.log"

To log hostname and the four-digit year in the custom log file, use log_host and log_year parameters respectively as follows:

Defaults  log_host, log_year, logfile="/var/log/sudo.log"

Below is an example of a custom sudo log file:
Create Custom Sudo Log File
Create Custom Sudo Log File
5. Log Sudo Command Input/Output

The log_input and log_output parameters enable sudo to run a command in pseudo-tty and log all user input and all output sent to the screen receptively.

The default I/O log directory is /var/log/sudo-io, and if there is a session sequence number, it is stored in this directory. You can specify a custom directory through the iolog_dir parameter.

Defaults   log_input, log_output

There are some escape sequences are supported such as %{seq} which expands to a monotonically increasing base-36 sequence number, such as 000001, where every two digits are used to form a new directory, e.g. 00/00/01 as in the example below:

$ cd /var/log/sudo-io/
$ ls
$ cd  00/00/01
$ ls
$ cat log

Log sudo Input Output
Log sudo Input Output

You can view the rest of the files in that directory using the cat command.
6. Lecture Sudo Users

To lecture sudo users about password usage on the system, use the lecture parameter as below.

It has 3 possible values:

    always – always lecture a user.
    once – only lecture a user the first time they execute sudo command (this is used when no value is specified)
    never – never lecture the user.

 
Defaults  lecture="always"

Additionally, you can set a custom lecture file with the lecture_file parameter, type the appropriate message in the file:

Defaults  lecture_file="/path/to/file"

Lecture Sudo Users
Lecture Sudo Users
7. Show Custom Message When You Enter Wrong sudo Password

When a user enters a wrong password, a certain message is displayed on the command line. The default message is “sorry, try again”, you can modify the message using the badpass_message parameter as follows:

Defaults  badpass_message="Password is wrong, please try again"

8. Increase sudo Password Tries Limit

The parameter passwd_tries is used to specify the number of times a user can try to enter a password.

The default value is 3:

Defaults   passwd_tries=5 

Increase Sudo Password Attempts
Increase Sudo Password Attempts

To set a password timeout (default is 5 minutes) using passwd_timeout parameter, add the line below:

Defaults   passwd_timeout=2

9. Let Sudo Insult You When You Enter Wrong Password

In case a user types a wrong password, sudo will display insults on the terminal with the insults parameter. This will automatically turn off the badpass_message parameter.

Defaults  insults 

Let's Sudo Insult You When Enter Wrong Password
Let’s Sudo Insult You When Enter Wrong Password

Read More: Let Sudo Insult You When You Enter Incorrect Password



https://www.tecmint.com/dmesg-commands/


https://www.tecmint.com/tag/linux-tricks/


